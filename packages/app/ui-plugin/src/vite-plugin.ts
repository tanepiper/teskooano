import path from "path";
import type { Plugin } from "vite";
import type { PluginLoadConfig, PluginRegistryConfig } from "./types.js"; // Removed Component types

/**
 * Options for the Teskooano UI Vite plugin.
 */
export interface TeskooanoUiPluginOptions {
  /** Array of absolute paths to plugin registry configuration files (e.g., pluginRegistry.ts). */
  pluginRegistryPaths: string[];
}

const VIRTUAL_MODULE_ID = "virtual:teskooano-loaders";
const RESOLVED_VIRTUAL_MODULE_ID = "\0" + VIRTUAL_MODULE_ID; // Vite convention

/**
 * Creates a Vite plugin for the Teskooano UI system.
 * This plugin reads plugin registry configurations and generates
 * a virtual module (`virtual:teskooano-loaders`) containing:
 *  - `pluginLoaders`: An object mapping plugin IDs to dynamic import functions.
 *
 * @param options - Configuration options for the plugin.
 * @returns A Vite Plugin instance.
 * @throws If required option `pluginRegistryPaths` is missing or empty.
 */
export function teskooanoUiPlugin(options: TeskooanoUiPluginOptions): Plugin {
  if (
    !options ||
    !options.pluginRegistryPaths ||
    options.pluginRegistryPaths.length === 0
  ) {
    throw new Error(
      "[Teskooano UI Plugin] Missing required option: pluginRegistryPaths (must be a non-empty array)",
    );
  }

  const pluginConfigPaths = options.pluginRegistryPaths.map((p) =>
    path.resolve(p),
  );

  // Map to track which plugin ID corresponds to which source file for HMR
  const pluginFileToIdMap = new Map<string, string>();

  return {
    name: "vite-plugin-teskooano-ui",

    /**
     * Resolves the virtual module ID for Vite.
     * @param id - The module ID being resolved.
     * @returns The resolved virtual module ID or null.
     */
    resolveId(id) {
      if (id === VIRTUAL_MODULE_ID) {
        return RESOLVED_VIRTUAL_MODULE_ID;
      }
      return null; // Let Vite handle other IDs
    },

    /**
     * Loads the content for the virtual module.
     * Reads plugin configurations, then generates dynamic import loaders.
     * @param id - The module ID being loaded.
     * @returns The generated virtual module content as a string, or null.
     */
    async load(id) {
      if (id === RESOLVED_VIRTUAL_MODULE_ID) {
        try {
          // --- Load Plugin Configs ---
          const pluginConfigsWithPaths: {
            id: string;
            config: PluginLoadConfig;
            dir: string;
          }[] = [];

          for (const configPath of pluginConfigPaths) {
            const pluginConfigModule = await import(
              configPath + `?import&t=${Date.now()}` // Append timestamp to bust cache
            );
            const pluginConfig: PluginRegistryConfig =
              pluginConfigModule.pluginConfig;

            if (!pluginConfig || typeof pluginConfig !== "object") {
              throw new Error(
                `Invalid or missing export 'pluginConfig' from ${configPath}`,
              );
            }
            const configDir = path.dirname(configPath);
            for (const [pluginId, loadConfig] of Object.entries(
              pluginConfig,
            )) {
              pluginConfigsWithPaths.push({
                id: pluginId,
                config: loadConfig,
                dir: configDir,
              });
            }
          }

          // Generate the virtual module content
          let content = `// Generated by vite-plugin-teskooano-ui\n// Timestamp: ${new Date().toISOString()}\n\n`;

          // Clear map before regenerating loaders
          pluginFileToIdMap.clear();

          content += "export const pluginLoaders = {\n";
          for (const {
            id: pluginId,
            config: loadConfig,
            dir: configDir,
          } of pluginConfigsWithPaths) {
            const resolvedPluginPath = path
              .resolve(configDir, loadConfig.path) // Resolve relative to its own config file
              .replace(/\\/g, "/"); // Ensure forward slashes

            pluginFileToIdMap.set(resolvedPluginPath, pluginId); // Populate map for HMR

            content += `  ${JSON.stringify(
              pluginId,
            )}: () => import('${resolvedPluginPath}'),\n`;
          }
          content += "};\n";

          return content;
        } catch (error) {
          console.error(
            "[Teskooano UI Plugin] Error loading configuration or generating virtual module:",
            error,
          );
          // Return empty exports on error to prevent build failures
          return "export const pluginLoaders = {};\n";
        }
      }
      return null; // Let Vite handle other IDs
    },

    /**
     * Handles Hot Module Replacement for plugin files.
     * When a plugin file changes, it sends a custom event to the client
     * to trigger a reload of that specific plugin.
     */
    handleHotUpdate({ file, server }) {
      const normalizedFile = path.normalize(file).replace(/\\/g, "/");
      const pluginId = pluginFileToIdMap.get(normalizedFile);

      if (pluginId) {
        console.log(
          `[HMR] Plugin file changed: ${file}. Reloading plugin: ${pluginId}`,
        );
        server.ws.send({
          type: "custom",
          event: "teskooano-plugin-update",
          data: { pluginId },
        });
        return []; // Indicate we handled this update, preventing a full page reload
      }
    },
  };
}
